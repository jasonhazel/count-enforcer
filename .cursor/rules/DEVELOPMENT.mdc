---
description: 
globs: 
alwaysApply: true
---
# Project Description

We are building a discord bot to track counting. 
- when the bot joins a server, it starts with a count of zero and one save
- users register to vote by sending the !register command.  this gives them the counter role
- only users with the counter role will be considered for counting.  they can run other commands though.
- count should increase by one with each valid message.
- users cannot double count
- server owner can double count for testing purposes
- when a user counts incorrectly, one save is removed (if available)
- if save is not available, set count to zero.
- we want to have full localization for any text that used by the bot.
- all owner-only commands are hidden from the !commands list
- easter egg commands are hidden from the !commands list

# Development Guidelines

This document outlines the core development rules and standards for the project.

## file structure guidelines
- files are always snake_case
- src
    - commands
        - [command].command.js
    - events
        - [event].event.js
    - lang
        - [lang].lang.js



## Git Workflow

### Branching Strategy
- Always create a new branch for code changes
- Branch names should follow the pattern:
  - `feature/` for new features
  - `bugfix/` for bug fixes
  - `hotfix/` for urgent fixes
- Follow with a descriptive name
- new branch should be created before each action.  
 - if current branch is not main and has not been commited, continue with current branch

### Commit Guidelines
- Write clear and descriptive commit messages
- Follow conventional commits format
- Keep commits atomic and focused on a single change
- Ensure all tests pass before committing
- Get code review before merging

## localization

### best practices
- any time text is being sent by the bot, it should use i18n localization
- any time new text is needed, make sure it has an appropriate entry in all language files.


## Docker Development

### Best Practices
- Test changes in the Docker environment before committing
- Update Dockerfile and docker-compose.yml when adding new dependencies
- Configure .dockerignore to exclude unnecessary files
- Keep Docker images optimized and minimal
- Document Docker configuration changes in commit messages

## Code Quality

### Standards
- Follow existing code style and formatting
- Write tests for new features and bug fixes
- Update documentation when changing functionality
- Keep functions small and focused
- Use meaningful variable and function names
- Maintain minimum test coverage of 80% for all new code

## Database/Persistence Guidelines
### Data Structure
- Store server data with a unique server ID as the primary key
- Maintain separate collections/tables for:
- Server configurations (count, saves, settings)
- User registrations (user IDs with counter role)
- Count history (for analytics and rollbacks)
### Database Operations
- Implement atomic transactions for critical operations (e.g., incrementing count)
- Use optimistic locking for concurrent counting operations
- Cache frequently accessed data (current count, user roles)
- Implement data validation before persistence
### Backup Strategy
- Schedule regular database backups
- Store backup history for at least 7 days
- Implement a recovery procedure for data corruption
### Performance
- Index frequently queried fields
- Use connection pooling for database connections
- Implement query optimization for high-traffic servers
- Monitor query performance and optimize slow queries
### Data Migration
- Version database schemas
- Document migration procedures for schema changes
- Test migrations thoroughly before deployment
- Provide rollback mechanisms for failed migrations
### Security
Encrypt sensitive data at rest
- Use parameterized queries to prevent injection
- Implement proper access controls to database
- Regularly audit database access patterns

## Testing Requirements

### Coverage and Standards
- Maintain minimum test coverage of 80% across the codebase
- Write unit tests for all new functions and methods
- Include integration tests for API endpoints and database operations
- Test both success and error cases
- Mock external dependencies in unit tests
- Run full test suite before committing changes
- Document test coverage reports in pull requests

## Security Guidelines

### Best Practices
- Never commit sensitive data or credentials
- Use environment variables for configuration
- Keep dependencies updated and secure
- Follow security best practices for Docker configurations

## Vue.js Development

### Standards
- Use Vue.js in Options API mode (not Composition API)
- Follow Vue.js style guide for component naming and structure
- Use PascalCase for component names
- Use kebab-case for custom event names
- Keep components focused and single-responsibility

### Vuetify Integration
- Use Vuetify components for UI elements when available
- Follow Vuetify's design system and spacing guidelines
- Implement responsive design using Vuetify's grid system
- Use Vuetify's built-in theming system for consistent styling
- Document component props, events, and slots

## JavaScript Standards

### Coding Standards
- Use ES6+ features appropriately
- Follow consistent naming conventions (camelCase for variables/functions)
- Use async/await for asynchronous operations
- Implement proper error handling
- Use destructuring and spread operators where appropriate
- Keep functions pure when possible
- Use TypeScript for type safety where applicable
- Document complex functions with JSDoc comments 